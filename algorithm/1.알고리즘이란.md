# 1. 알고리즘이란?

## 1-1. 알고리즘

어떤 문제를 해결하기 위해 밟아 나가는 연속적인 단계

도날드 커누스는 알고리즘을 ‘입력을 기반으로 출력을 생성하는 명확하고, 효율적이며 유한한 프로세스’라고 정의

- **명확함** **(Definiteness)** 이란 각 단계가 명료하고  모호하지 않다는 뜻입니다.
- **효율성** **(Effectiveness)** 이란 각 동작이 문제 결에 기여한다는 뜻입니다.
- **유한함** **(Finiteness)** 이란 알고리즘이 유한한 단계를 거친 후 종료된다는 뜻입니다.
- **정확성**을 추가하는 경우도 많은데, 입력이 같으면 항상 같은 결과를 내야 한다.

정확성의 요건에는 난수 발생기와 같은 예외가 존재하고, 데이터 과학의 알고리즘은 정확성을 엄격히 따지지 않음

## 1-2. 알고리즘 분석

알고리즘의 실행 시간은 알고리즘을 평가하는 기준 중 하나.

**실행 시간**은 파이썬 같은 프로그래밍 언어로 만든 알고리즘을 컴퓨터가 실행하는 데 걸리는 시간을 말함.

```python
import time

start = time.time()
for i in range(1,6):
		print(i)
end = time.time()
pritn(end-start)
```

프로그램을 실행하면 실행 시간은 달라짐 

- 프로그램을 실행하는 순간 컴퓨터가 사용할 수 있는 CPU의 자원이 매번 다름
- 이 자원이 프로그램의 실행 시간에 영향을 미치므로 알고리즘의 실행 시간도 매번 달라지는 것
- 컴퓨터의 성능에 따라 달라짐
- 프로그래밍 언어에 따라서도 달라짐

두 개 이상의 알고리즘을 비교해야 한다면 프로그래밍 언어나 컴퓨터의 사양과 같은 변수는 제외하고, 알고리즘에 필요한 단계를 수식으로 비교함

```python
for i in range(1,6):
		print(i)
```

이 프로그램은 다섯 번의 루프를 실행하면서 i를 출력하므로 총 다섯 번의 단계를 거침. 

이 알고리즘에 필요한 단계는 $f(n)$으로 표현할 수 있음

```
f(n) = 5
```

프로그램이 복잡해지면 $f(n)$도 바뀜

```python
count = 0
for i in range(1,6):
		print(i)
		count += i
```

이 알고리즘은 11번의 단계를 거침. 

- count 변수에 0을 할당(1)
- 1~5까지 출력(5)
- 출력한 숫자의 합을 구함(5)

숫자 6을 n으로 바꾸면 f(n)은 다음과 같다.

```
f(n) = 1 + 2n
```

$f(n)$의 1은 count = 0에 해당하고, 숫자를 출력하고 합을 구하는 2n만큼의 단계가 필요

컴퓨터 과학자는 알고리즘의 단계를 나타내는 $f(n)$의 변수 n을 **데이터의 크기**라고 부름

n의 변화에 따른 알고리즘 성능의 변화를 예상하는 것이 중요

데이터의 크기가 늘어날 때마다 알고리즘의 단계가 얼마나 늘어나는지를 대략적으로 파악하는 것이 가장 중요

알고리즘의 효율에서 가장 중요한 부분은 ‘n이 커질 때 알고리즘의 단계가 얼마만큼 증가하는가’임

## 1-3. 빅 O 표기법

빅 O 표기법은 n이 커짐에 따라 알고리즘의 시간 또는 공간의 요건이 얼마나 커지는지를 나타내는 수학적 표기법

빅 O 표기법은 T(n)에서 규모 함수를 도출

규모란 차이가 아주 큰 등급 체계에서의 크기 차이를 뜻함

규모 함수에서는 알고리즘의 실행 단계를 나타내는 T(n)에서 수식을 지배하는 부분만 남기고, 나머지는 모두 무시

```mermaid
flowchart LR
  상수시간 --> 로그시간 --> 선형시간 --> 선형로그시간 --> 2차시간 --> 3차시간 --> 지수시간
```

빅 O 표기법에서 가장 널리 사용되는 규모 함수들을 최선(가장 효율적)에서 최악(가장 비효율적)의 순서로 나열

각각의 규모 함수는 알고리즘의 시간 복잡도를 나타냄.

시간 복잡도란 n이 커짐에 따라 알고리즘이 실행되고 완료될 때까지 필요한 단계를 말함

### 상수 시간

가장 효율적인 규모.

어떤 알고리즘이 n의 크기에 관계없이 동일한 단계만 필요한 경우 ‘알고리즘이 **상수 시간**으로 실행된다’고 말함

빅 O 표기법으로 표기하면 $O(1)$과 같음

데이터 세트가 아무리 커지더라도 알고리즘의 실행 시간이 변하지 않으므로 가장 효율적인 알고리즘이라고 할 수 있음

### 로그  시간

데이터의 로그에 비례해 알고리즘의 단계가 늘어날 때, 로그 시간으로 실행된다고 말함

실행을 반복할 때마다 탐색의 범위를 1/2로 줄여 나가는 이진 탐색과 같은 알고리즘에서 볼 수 있음

빅 O 표기법으로 표기하면 $O(log n)$과 같음

데이터 세트가 커짐에 따라 알고리즘의 실행에 필요한 단계가 천천히 늘어나는 알고리즘

### 선형 시간

데이터의 크기가 커지는 만큼 같은 비율로 단계가 늘어나는 알고리즘

빅 O 표기법에서는 $O(n)$으로 표기

```python
free_book = False
customers = ["Lexi", "Britney", "Danny", "Bobbi", "Chris"]
for customer in custormers:
		if customer[0] == 'B':
				print(customer)
```

고객이 다섯 명이라면 프로그램도 이름을 탐색하는 다섯 번의 단계를 거쳐야 됨

고객의 숫자에 따라 이름 탐색

free_book과 customers에 할당하는 단계와 고객 리스트에서는 B로 시작하는 이름을 탐색하는 n번의 단계를 더해 다음과 같이 나타낼 수 있음

```
f(n)= 1+1+n
```

빅 O 표기법에서는 상수 부분을 무시하고 $f(n)$을 지배하는 부분만 선택해 다음과 같이 나타냄

```
O(n)= n
```

### 선형 로그 시간

로그 시간 복잡도와 선형 시간 복잡도를 곱한 만큼 커짐

로그 시간으로 실행되는 알고리즘 O(log n)을 n번 번복하는 형태를 말하며, O(n log n)으로 표기함

데이터 세트를 작은 부분으로 나누고, 이들을 독립적으로 처리하는 형태를 취함

### 2차 시간

2차 시간으로 실행되는 알고리즘의 복잡도는 n의 제곱에 정비례하여, O(n**2)으로 표기함

```python
numbers = [1, 2, 3, 4, 5]
for i in numbers:
		for j in numbers:
				x = i * j
				print(x)
```

이 알고리즘은 숫자 리스트 numbers에 들어 있는 모든 숫자를 서로 곱해 변수에 저장한 후 출력

n은 numbers 리스트의 크기이므로, 이 알고리즘의 시간 복잡도 f(n)은 다음과 같이 나타낼 수 있음

```python
f(n) = 1 + n * n * (1+1)
```

(1+1)부분은 각각(i * j)를 변수 x에 저장하는 단계와 print 함수에 해당함

두 번 중첩된 for 루프를 통해 곱셈과 출력을 n * n번 반복함

f(n)의 크기를 지배하는 부분이 n**2이므로 빅 O 표기법으로는 다음과 같이 나타낼 수 있음

```python
O(n) = n**2
```

n의 제곱에 비례해 실행 시간이 늘어나는 삽입 정렬이나 버블 정렬과 같은 정렬 알고리즘의 상당수가 2차 시간 복잡도를 따름

### 3차 시간

```python
numbers = [1, 2, 3, 4, 5]
for i in numbers:
		for j in numbers:
				for h in numbers:
					x = i * j * h
					print(x)
```

```
f(n) = 1+n*n*n*(1+1)
```

```
f(n) = 1+2*n**3
```

2차 시간 복잡도와 마찬가지로 f(n)에서 가장 중요한 부분은 n**3임.

n**3은 너무나 급격하게 커지기 때문에 만약 f(n)의 나머지 부분에 n**2이 포함되어 있더라도 무시할 수 있을 정도임.

```python
O(n) =  n**3
```

다항 시간 복잡도를 따르는 알고리즘은 O(n**a)에 비례하여 커짐

알고리즘을 설계할 때는 가급적 다항 시간 알고리즘을 피하는 편이 좋음

### 지수 시간

최악의 시간 복잡도

지수 시간으로 실행되는 알고리즘의 복잡도는 데이터 크기의 지수식으로 표현됨

어떤 상수 c를 n 제곱한 만큼 실행 단계가 커지는 알고리즘으로, 빅 O 표기법에서는 O(c**n)으로 표기함

상수가 얼마나 큰 지가 중요하지 않고, 지수인 n이 문제임

```python
pin = 931
n = len(pin)
for i in range(10**n):
		if i == pin:
				print(i)
```

## 1-4. 공간 복잡도

알고리즘의 실행을 완료할 때까지 필요한 자원의 양, 즉 고정 공간, 데이터 구조 공간, 임시 공간의 메모리를 얼마나 사용하는지 나타냄

- **고정 공간**은 프로그램 자체가 차지하는 메모리를 말함
- **자료구조 공간**은 데이터 세트, 예를 들어 탐색의 대상이 되는 리스트를 저장하는 데 필요한 메모리
- **임시 공간**은 데이터를 저장하기 위해 중간 처리를 위해 사용하는 메모리 예를 들어 데이터 전송을 위해 임시로 리스트 사본을 만들 때 필요한 메모리

n의 팩토리얼을 계산하는 알고리즘은 상수 공간 복잡도O(1)을 따름

```python
x=1
n=5
for i in range(1,n+1):
		x= x*i
```

공간 복잡도가 상수인 이유는 n이 커져도 알고리즘에서 추가로 메모리를 사용하지 않음

n까지 도달하면서 계산한 중간 결과를 모두 리스트에 저장하면 선형 공간 복잡도O(n)을 따름

```python
x=1
n=5
a_list = []
for i in range(1,n+1):
	a_list.append(x)
		x= x*i
```

알고리즘에 필요한 공간 역시 n이 커지는 것과 같은 비율로 커지므로 이 알고리즘의 공간 복잡도가 O(n)이 되는 것임
