# 2. 재귀

## 2-1. 재귀

**반복 알고리즘**은 동일한 루프로 단계를 반복해 문제를 해결하는 알고리즘을 말함

재귀는 문제를 더 작은 부분으로 나누고, 각 부분의 문제를 해결한 후 결과를 조합해 전체 문제의 답을 찾는 문제 해결 방법

반복 알고리즘으로 해결할 수 있는 문제는 모두 재귀 알고리즘으로도 해결할 수 있으며, 재귀 알고리즘이 더 간결한 형태일 때가 많다.

재귀 알고리즘의 함수는 입력을 변경하고 자신을 호출하면서 그 결과를 전달하는 방식으로 작동

재귀 함수가 자기 자신을 끝도 없이 호출하지 않도록 재귀 알고리즘을 빠져나가는 **종료 조건**이 반드시 필요

- 반드시 종료 조건이 필요하다
- 반드시 자기 자신의 상태를 변경하면서 종료 조건에 가까워져야 한다
- 반드시 자기 자신을 재귀적으로 (다시 돌아와) 호출해야 한다

## 2-2. 팩토리얼로 알아보는 재귀함수

팩토리얼이란 어떤 숫자 이하의 양의 정수를 모두 곱한 값이다.

다음은 숫자 n의 팩토리얼을 계산하는 반복 알고리즘이다.

```python
def factorial(n): # 계산에 필요한 숫자 n을 매개변수로 받음
	# n 이하인 양의 정수들의 곱을 저장할 the_product 변수를 정의하고 초기값 지정
	# the_product는 n에 도달하는 숫자들의 곱을 저장하는 데 사용
	the_product = 1 
	# while 루프를 사용해 역으로 n이 1이 될 때까지 계산을 반복
	while n > 0: 
			the product *= n
			n = n-1
	return the product # while 루프가 끝나면 n의 팩토리얼이 저장된 the_product 출력
```

재귀 알고리즘으로 변경한 것

```python
def factorial(n): # n을 매개변수로 받는 fatorial 함수 정의
	# 재귀 알고리즘을 빠져 나가는 종료 조건을 작성
	# n이 0이 될 때까지 자신을 반복적으로 호출하며 n이 0이 되면 1을 반환하고 호출 중단
	if n==0: 
			return 1
	# factorial 자기 자신을 호출
	# 자신을 호출한 결과를 반환하지만, 자신이 호출할 때 n이 아니라 n-1을 매개변수로 전달
	# 결국에는 n이 1보다 작아지면서 다음의 종료 조건을 만족하게 됨
	return n * factorial(n-1)
```

factorial 함수는 내부적으로 return문을 만날 때마다 그 반환값을 스택에 담음

스택은 파이썬의 리스트와 비슷하지만, 데이터를 추가한 순서대로 데이터를 제거함

예를 들어, factorial 함수를 호출

```python
factorial(3)
return n * factorial(n-1)
```

변수 n은 3으로 시작함 

factorial 함수는 먼저 종료 조건을 확인하고, n이 0이 아니므로 False로 평가해 그 다음 행을 실행

파이썬은 현 시점에서 아직 n * factorial(n-1)의 결과를 알지 못하므로 이를 스택에 저장함.

```python
# 내부 스택(실행하는 코드가 아님)
# 파이썬이 마지막 반환값을 알고 있으므로 이전의 결과를 계산하고 스택에서 제거할 수 있음
# 1 * n을 계산하며 여기서 n은 1임
[
	return n * factorial(n-1), # n = 3
	return n * factorial(n-1), # n = 2
	return n * factorial(n-1), # n = 1
	1
]

# 마지막 반환 값을 알고 있으므로 이전의 결과를 계산하고 스택에서 제거함
[
	return n * factorial(n-1), # n = 3
	return n * factorial(n-1), # n = 2
	1
]

[
	return n * factorial(n-1), # n = 3
	2
]
# 스택에 남아 있는 이전 결과를 계산하고 그 값을 반환
3 * 2 =6

# 내부 스택
[return 6]
```

팩토리얼 계산은 같은 문제를 더 작은 부분들로 나누어 해결할 수 있는 아주 좋은 예제

재귀 알고리즘을 작성함으로써 숫자의 팩토리얼 계산을 간결하게 해결

## 2-3. 재귀를 사용해야 할 때

재귀로 해결할 수 있는 문제는 반복으로도 해결할 수 있음

재귀의 장점은 간결함이다.

재귀의 단점은 파이썬의 내부 스택에 데이터를 저장하므로 메모리를 더 소비할 때가 많다는 것임

알고리즘이 어떻게 작동되고 있는지 한눈에 파악하기 어려운 편이므로 반복 알고리즘에 비해 디버깅이 어려움